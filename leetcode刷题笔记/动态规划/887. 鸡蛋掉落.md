1. 状态 $f(i, j)$ 表示进行 $i$ 次移动，有 $j$ 个鸡蛋，最多可以检查的楼层高度是多少。
2. 先给出转移方程， $f(i, j)=f(i-1, j-1)+f(i-1, j)+1$ 。假设 $n_1=f(i-1, j-1), n_2=f(i-1, j)$ ，我们在第 $i$ 次移动时测试第 $n_1+1$ 层。
3. 如果测试时鸡蛋碎掉了，则我们可以通过 $i-1$ 次移动和 $j-1$ 个鸡蛋来找到最高不会碎掉楼层，因为楼层不会超过 $n_1$ 了；如果鸡蛋没有碎掉，则在此基础上，我们可以使用 $i-1$ 次移动和 $j$ 个鸡蛋，再继续向上检查 $n_2$ 层，故只要是答案在 $\left[0, n_1+n_2+1\right]$ 范围内，都可以通过 $i$ 步和 $j$ 个鸡蛋来找到。
4. 返回最小的 $m$ 满足， $f(m, k) \geq n$ 。
6. 这里，状态的第一维可以省略，更新时只需要倒序更新即可。

```c++
class Solution {
public:
    int superEggDrop(int k, int n) {
        // f[i][j]表示有j个鸡蛋，扔i次能得到答案的最大高度
        // f[i][j] = f[i - 1][j - 1] + 1 + f[i - 1][j]
        vector<vector<int>> f(n + 1, vector<int>(k + 1));
        for(int i = 1; i <= n; i ++)
        {
            for(int j = 1; j <= k; j ++)
            {
                f[i][j] = f[i - 1][j - 1] + 1 + f[i - 1][j];
            }
            if(f[i][k] >= n) return i;
        }
        return -1;
    }
};
```

