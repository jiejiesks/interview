这道题目可以用动态规划来做。
状态表示: $f[i]$ 表示前 $i$ 个数字共有多少种解码方式。
初始化: 0 个数字解码的方案数 1 ，即 $f[0]=1$ 。
状态转移: $f[i]$ 可以表示成如下两部分的和:
- 如果第 $i$ 个数字不是 0 , 则 $i$ 个数字可以单独解码成一个字母，此时的方案数等于用前 $i-1$ 个数字解码的方案数, 即 $f[i-1]$;
- 如果第 $i-1$ 个数字和第 $i$ 个数字组成的两位数在 10 到 26 之间，则可以将这两位数字解码成一个字符，此时的方案数等于用前 $i-2$ 个数字解码的方案数，即 $f[i-2]$ ；

时间复杂度分析: 状态数是 $n$ 个, 状态转移的时间复杂度是 $O(1)$ ，所以总时间复杂度是 $O(n)$ 。

```c++
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        s = ' ' + s;
        vector<int> f(n + 1);
        f[0] = 1;
        for(int i = 1; i <= n; i ++)
        {
            if(s[i] >= '1' && s[i] <= '9') f[i] += f[i - 1];
            if(i > 1)
            {
                int t = (s[i - 1] - '0') * 10 + s[i] - '0';
                if(t >= 10 && t <= 26) f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
```

